#!/usr/bin/env ruby
# This lets us to run this from the command line as ./twitter instead of `ruby
# twitter`

require 'json'
require 'simple_oauth'
require 'excon'
require_relative 'lib/twitter_creds'
require_relative 'lib/twitter'
require 'pp'

if API_KEY.nil? || API_SECRET.nil?
  puts 'Make sure you configure your Twitter application first. See README.md.'
  puts 'Your Twitter API key and API secret need to go in .env'
end

### GOALS

# See any users timeline -- ./twitter timeline zspencer
# See any users information (Join date, location, etc.) -- ./twitter info jfarmer
# See any users followers -- ./twitter followers <yourhandle>
# See who is following any user -- ./twitter following <yourhandle>
# Send a tweet -- ./twitter tweet I know kung fu
# Send a DM -- ./twitter message zspencer do you know kung fu?
# Follow a user -- ./twitter follow jfarmer
# Unfollow a user -- ./twitter unfollow zspencer

### QUESTIONS

# Any improvements on how I abstracted the authorization headers and query?
# Any improvements on method or variable names?
# Should I try to create one JSON method that's always used to parse the API response?
# Should results for each command be standarized to a common format? If so, what should it be?

### METHODS

# Contains high-level variables and methods for a Twitter command-line client
class Twitter
  def run_app(command, arguments)
    case command
    when 'timeline'
      # Passing only first argument makes command more error-tolerant
      results = timeline(arguments[0])
    when 'info'
      results = info(arguments[0])
    else
      puts '#{command} command not yet supported.'
    end

    results
  end

  def timeline(screen_name)
    uri = 'https://api.twitter.com/1.1/statuses/user_timeline.json'

    auth_header = auth_header('get', uri, screen_name)
    response = query('get', uri, screen_name, auth_header)

    tweets_json = JSON.parse(response.body)
    tweets = json_values(tweets_json, "text")
  end

  def info(screen_name)
    uri = 'https://api.twitter.com/1.1/users/show.json'

    auth_header = auth_header('get', uri, screen_name)
    response = query('get', uri, screen_name, auth_header)

    info_json = JSON.parse(response.body)

    results = {}
    results["name"] = info_json["name"]
    results["joined"] = info_json["created_at"]
    results["location"] = info_json["location"]
    results["description"] = info_json["description"]

    results
  end
end

def json_values(json, key)
  values = []
  json.each do |hash|
    values << hash[key]
  end

  values
end

def auth_header(request, uri, screen_name)
  SimpleOAuth::Header.new(request,
                          uri,
                          { screen_name: screen_name },
                          consumer_key: API_KEY,
                          consumer_secret: API_SECRET,
                          token: ACCESS_TOKEN,
                          token_secret: ACCESS_TOKEN_SECRET)
end

def query(request, uri, screen_name, auth_header)
  Excon.send(request,
             uri,
             query: { screen_name: screen_name },
             headers: { authorization: auth_header.to_s }
             )
end

### MAIN

command = ARGV.shift
arguments = ARGV
twitter = Twitter.new
results = twitter.run_app(command, arguments)
PP.pp results

### TESTS

# twitter = Twitter.new
# tweets = twitter.run_app('timeline','goldenson')
# puts tweets.include?("See if you can explain this. :) http://t.co/GskFzjQsip")

# authorization_header = SimpleOAuth::Header.new("post",
# "https://api.twitter.com/1.1/direct_messages/new.json",
# { :screen_name => "goldenson",
#   :text => "I can send myself DMs in Ruby!" },
#   { :consumer_key => API_KEY,
#     :consumer_secret => API_SECRET,
#     :token => ACCESS_TOKEN,
#     :token_secret => ACCESS_TOKEN_SECRET })
#
#     response = Excon.send("post", "https://api.twitter.com/1.1/direct_messages/new.json", {
#       :query => { :screen_name => "goldenson",
#         :text => "I can send myself DMs in Ruby!" },
#         :headers => { "Authorization" => authorization_header.to_s }
#         })
#
#         puts response.body
#         puts response.status
