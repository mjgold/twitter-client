#!/usr/bin/env ruby
# This lets us to run this from the command line as ./twitter instead of `ruby
# twitter`

require 'json'
require 'simple_oauth'
require 'excon'
require_relative 'lib/twitter_creds'
require_relative 'lib/twitter'
require 'pp'

if API_KEY.nil? || API_SECRET.nil?
  puts 'Make sure you configure your Twitter application first. See README.md.'
  puts 'Your Twitter API key and API secret need to go in .env'
end

### GOALS

# See any users timeline -- ./twitter timeline zspencer
# See any users information (Join date, location, etc.) -- ./twitter info jfarmer
# See any users followers -- ./twitter followers <yourhandle>
# See who is following any user -- ./twitter following <yourhandle>
# Send a tweet -- ./twitter tweet I know kung fu
# Send a DM -- ./twitter message zspencer do you know kung fu?
# Follow a user -- ./twitter follow jfarmer
# Unfollow a user -- ./twitter unfollow zspencer

### QUESTIONS

# Any improvements on how I abstracted the authorization headers and query?
# Any improvements on method or variable names?
# Should I try to create one JSON method that's always used to parse the API response?
# Should results for each command be standarized to a common format? If so, what should it be?

### METHODS

# Contains high-level variables and methods for a Twitter command-line client
class Twitter

  attr_reader :command, :arguments

  def initialize(command = nil, arguments = nil, next_cursor_str = nil)
    @command = command
    @arguments = arguments
    @next_cursor_str = next_cursor_str

    run_app(command, arguments)
  end

  def run_app(command, arguments)
    @command = command
    @arguments = arguments

    case command
    when 'timeline'
      # Passing only first argument makes command more error-tolerant
      results = timeline(arguments[0])
    when 'info'
      results = info(arguments[0])
    when 'followers'
      results = followers(arguments[0])
    else
      puts "#{command} not yet a supported command."
    end

    results
  end

  def timeline(screen_name)
    uri = 'https://api.twitter.com/1.1/statuses/user_timeline.json'

    auth_header = auth_header('get', uri, screen_name)
    response = query('get', uri, screen_name, auth_header)

    tweets_json = JSON.parse(response.body)
    error_check(tweets_json)

    tweets = json_values(tweets_json, "text")
  end

  def info(screen_name)
    uri = 'https://api.twitter.com/1.1/users/show.json'

    auth_header = auth_header('get', uri, screen_name)
    response = query('get', uri, screen_name, auth_header)

    info_json = JSON.parse(response.body)
    error_check(info_json)

    results = {}
    results["name"] = info_json["name"]
    results["joined"] = info_json["created_at"]
    results["location"] = info_json["location"]
    results["description"] = info_json["description"]

    results
  end
end

def followers(screen_name)
  # Send query and get 20 followers
  # Print ID and name of 20 followers to screen
  # Ask user if they want 20 more results (y/n)
  # Send 20 more if yes, quit if no
  uri = 'https://api.twitter.com/1.1/followers/list.json'

  auth_header = auth_header('get', uri, screen_name)
  response = query('get', uri, screen_name, auth_header)

  followers_json = JSON.parse(response.body)
  error_check(followers_json)
  users_json = followers_json['users']
  screen_names = json_values(users_json, 'screen_name')
  @next_cursor_str = followers_json['next_cursor_str']

  screen_names
end

def json_values(json, key)
  values = []
  json.each do |hash|
    values << hash[key]
  end

  values
end

def error_check(json)
  errors = json["errors"]
  unless errors.nil?
    puts "Twitter API reports errors!"
    errors.each do |error|
      puts error[message]
    end
    quit
  end
end

def auth_header(request, uri, screen_name)
  SimpleOAuth::Header.new(request,
                          uri,
                          { screen_name: screen_name },
                          consumer_key: API_KEY,
                          consumer_secret: API_SECRET,
                          token: ACCESS_TOKEN,
                          token_secret: ACCESS_TOKEN_SECRET)
end

def query(request, uri, screen_name, auth_header)
  Excon.send(request,
             uri,
             query: { screen_name: screen_name },
             headers: { authorization: auth_header.to_s }
             )
end

def print_results(results)
  puts "command: #{@command}"
  if @command == 'followers'
    PP.pp results
    if want_more_results?
      puts "got here"
      twitter.run_app('followers', arguments[0], next_cursor)
    end
  else
    PP.pp results
  end
end

def want_more_results?
  puts "Do you want 20 more results? (y/n):"
  answer = gets.chomp
  case answer
  when 'y'
    return true
  when 'n'
    return false
  else
    puts "Yo, I don't understand. Please enter 'y' or 'n'."
  end
end

### MAIN

command = ARGV.shift
arguments = ARGV
twitter = Twitter.new
results = twitter.run_app(command, arguments)
print_results(results)

### TESTS

# twitter = Twitter.new
# tweets = twitter.run_app('timeline','goldenson')
# puts tweets.include?("See if you can explain this. :) http://t.co/GskFzjQsip")

# authorization_header = SimpleOAuth::Header.new("post",
# "https://api.twitter.com/1.1/direct_messages/new.json",
# { :screen_name => "goldenson",
#   :text => "I can send myself DMs in Ruby!" },
#   { :consumer_key => API_KEY,
#     :consumer_secret => API_SECRET,
#     :token => ACCESS_TOKEN,
#     :token_secret => ACCESS_TOKEN_SECRET })
#
#     response = Excon.send("post", "https://api.twitter.com/1.1/direct_messages/new.json", {
#       :query => { :screen_name => "goldenson",
#         :text => "I can send myself DMs in Ruby!" },
#         :headers => { "Authorization" => authorization_header.to_s }
#         })
#
#         puts response.body
#         puts response.status
