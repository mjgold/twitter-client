#!/usr/bin/env ruby
# This lets us to run this from the command line as ./twitter instead of `ruby
# twitter`

require 'json'
require 'simple_oauth'
require 'excon'
require_relative 'lib/twitter_creds'
require_relative 'lib/twitter'
require 'pp'

if API_KEY.nil? || API_SECRET.nil?
  puts 'Make sure you configure your Twitter application first. See README.md.'
  puts 'Your Twitter API key and API secret need to go in .env'
end

### COMMANDS

# See any users timeline -- ./twitter timeline zspencer
# See any users information -- ./twitter info jfarmer
# See any users followers -- ./twitter followers <yourhandle>
# See who is following any user -- ./twitter following <yourhandle>
# Send a tweet -- ./twitter tweet I know kung fu
# Send a DM -- ./twitter message zspencer do you know kung fu?
# Follow a user -- ./twitter follow jfarmer
# Unfollow a user -- ./twitter unfollow zspencer

### QUESTIONS

# Any improvements on how I abstracted the authorization headers and query?
# Any improvements on method or variable names?
# Should I try to create one JSON method that's always used to parse the API response?
# Should results for each command be standarized to a common format? If so, what should it be?

### METHODS

# Contains high-level variables and methods for a Twitter command-line client
class Twitter
  attr_reader :command, :arguments

  def run_app(command, arguments, next_cursor_str = '-1')
    case command
    when 'timeline'
      # Passing only first argument makes command more error-tolerant
      results = timeline(arguments[0])
    when 'info'
      results = info(arguments[0])
    when 'followers'
      results = followers(arguments[0], next_cursor_str)
    when 'following'
      results = following(arguments[0], next_cursor_str)
    when 'tweet'
      tweet = arguments.join(" ")
      results = tweet(tweet)
    when 'message'
      recipient = arguments.shift
      message = arguments.join(" ")
      results = dm(recipient, message)
    else
      puts "#{command} not yet a supported command."
    end

    results
  end

  def timeline(screen_name)
    uri = 'https://api.twitter.com/1.1/statuses/user_timeline.json'

    options = { screen_name: screen_name }
    tweets_json = send_request_and_get_json('get', uri, options)

    { results: json_values(tweets_json, 'text') }
  end

  def info(screen_name)
    uri = 'https://api.twitter.com/1.1/users/show.json'

    options = { screen_name: screen_name }
    info_json = send_request_and_get_json('get', uri, options)

    results = {}
    results['name'] = info_json['name']
    results['joined'] = info_json['created_at']
    results['location'] = info_json['location']
    results['description'] = info_json['description']

    { results: results }
  end

  def followers(screen_name, next_cursor_str)
    uri = 'https://api.twitter.com/1.1/followers/list.json'

    follow_request(uri, screen_name, next_cursor_str)
  end

  def following(screen_name, next_cursor_str)
    uri = 'https://api.twitter.com/1.1/friends/list.json'

    follow_request(uri, screen_name, next_cursor_str)
  end

  def follow_request(uri, screen_name, next_cursor_str)
    options = { screen_name: screen_name, cursor: next_cursor_str }
    follow_json = send_request_and_get_json('get', uri, options)

    users_json = follow_json['users']
    screen_names = json_values(users_json, 'screen_name')
    next_cursor_str = follow_json['next_cursor_str']

    { results: screen_names, next_cursor_str: next_cursor_str }
  end

  def tweet(tweet)
    uri = 'https://api.twitter.com/1.1/statuses/update.json'
    options = { status: tweet }

    tweet_json = send_request_and_get_json('post', uri, options)
    posted_tweet = tweet_json['text']

    { results: posted_tweet }
  end

  def dm(screen_name, message)
    uri = 'https://api.twitter.com/1.1/direct_messages/new.json'
    options = { screen_name: screen_name, text: message }

    dm_json = send_request_and_get_json('post', uri, options)
    sent_dm = dm_json['text']

    { results: sent_dm }
  end

  def send_request_and_get_json(request_type, uri, options)
    auth_header = auth_header(request_type, uri, options)
    response = query(request_type, uri, auth_header, options)
    json = JSON.parse(response.body)
    error_check(json) ### Why doesn't this work for timeline command?

    json
  end

  def auth_header(request, uri, options)
    SimpleOAuth::Header.new(request,
                            uri,
                            options,
                            consumer_key: API_KEY,
                            consumer_secret: API_SECRET,
                            token: ACCESS_TOKEN,
                            token_secret: ACCESS_TOKEN_SECRET)
  end

  def query(request, uri, auth_header, options)
    params = { query: options,
               headers: { Authorization: auth_header.to_s }
             }

    Excon.send(request, uri, params)
  end

  def json_values(json, key)
    values = []
    json.each do |hash|
      values << hash[key]
    end

    values
  end

  def error_check(json)
    errors = json[:errors]
    return true if errors.nil?

    puts 'Twitter API reports errors!'
    errors.each do |error|
      puts error[:message]
    end
    exit
  end

  def print_results(results)
    PP.pp results[:results]
  end

  def want_more_results?
    print 'Do you want 20 more results? (y/n): '
    answer = $stdin.gets.chomp # Using $stdin, else normal gets takes ARGV args
    case answer
    when 'y'
      return true
    when 'n'
      return false
    else
      puts "Yo, I don't understand. Please enter 'y' or 'n'."
      want_more_results?
    end
  end
end

### MAIN

command = ARGV.shift
arguments = ARGV
twitter = Twitter.new

results = twitter.run_app(command, arguments)
twitter.print_results(results)

if command == 'followers' || command == 'following'
  while twitter.want_more_results?
    next_cursor_str = results[:next_cursor_str]
    results = twitter.run_app(command, arguments, next_cursor_str)
    twitter.print_results(results)
  end
end

### TESTS

# twitter = Twitter.new
# tweets = twitter.run_app('timeline','goldenson')
# puts tweets.include?("See if you can explain this. :) http://t.co/GskFzjQsip")
